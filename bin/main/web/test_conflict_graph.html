<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å†²çªå›¾æµ‹è¯•</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #1a1a1a;
            color: white;
        }
        
        #conflict-graph-container {
            width: 100%;
            height: 600px;
            border: 1px solid #444;
            border-radius: 8px;
            background-color: #222;
            overflow: hidden;
        }
        
        .node-group {
            cursor: grab;
        }
        
        .node-group:hover circle.main {
            stroke: #fff;
            stroke-width: 3;
        }
        
        .link {
            stroke-width: 1;
        }
        
        .link.conflict {
            stroke: #ff6b6b;
        }
        
        .link.compatible {
            stroke: #4ecdc4;
        }
        
        .link.weak {
            stroke: #a0aec0;
        }
        
        .tooltip {
            position: absolute;
            padding: 8px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            border: 1px solid #444;
            border-radius: 4px;
            pointer-events: none;
            font-size: 12px;
            opacity: 0;
            transition: opacity 0.3s;
        }
    </style>
</head>
<body>
    <h1>å†²çªå›¾å¯è§†åŒ–æµ‹è¯•</h1>
    <div id="conflict-graph-container"></div>
    <div id="tooltip" class="tooltip"></div>
    
    <script>
        // æ¨¡æ‹Ÿæ•°æ®
        const enchantments = {
            "weapon": {
                "name": "æ­¦å™¨é™„é­”",
                "color": "#FF6B6B",
                "icon": "âš”ï¸",
                "enchantments": [
                    {"id": "sharpness", "name": "é”‹åˆ©", "description": "å¢åŠ ä¼¤å®³"},
                    {"id": "fire_aspect", "name": "ç«ç„°é™„åŠ ", "description": "ç‚¹ç‡ƒç›®æ ‡"},
                    {"id": "knockback", "name": "å‡»é€€", "description": "å¢åŠ å‡»é€€è·ç¦»"}
                ]
            },
            "armor": {
                "name": "æŠ¤ç”²é™„é­”",
                "color": "#4ECDC4", 
                "icon": "ğŸ›¡ï¸",
                "enchantments": [
                    {"id": "protection", "name": "ä¿æŠ¤", "description": "å‡å°‘ä¼¤å®³"},
                    {"id": "thorns", "name": "è†æ£˜", "description": "åå¼¹ä¼¤å®³"}
                ]
            },
            "tool": {
                "name": "å·¥å…·é™„é­”",
                "color": "#FFE66D",
                "icon": "â›ï¸",
                "enchantments": [
                    {"id": "efficiency", "name": "æ•ˆç‡", "description": "æé«˜æŒ–æ˜é€Ÿåº¦"},
                    {"id": "fortune", "name": "æ—¶è¿", "description": "å¢åŠ æ‰è½"}
                ]
            }
        };

        const conflictRules = {
            "weapon": {
                "conflicts": [],
                "compatible": ["armor"],
                "weak": ["tool"]
            },
            "armor": {
                "conflicts": [],
                "compatible": ["weapon"],
                "weak": ["tool"]
            },
            "tool": {
                "conflicts": [],
                "compatible": ["weapon", "armor"],
                "weak": []
            }
        };

        // å·¥å…·å‡½æ•°
        function showTooltip(event, d) {
            const tooltip = document.getElementById("tooltip");
            if (!tooltip) return;
            
            let content = "<strong>" + d.name + "</strong>";
            if (d.description) {
                content += "<br>" + d.description;
            }
            
            tooltip.innerHTML = content;
            tooltip.style.left = (event.pageX + 10) + "px";
            tooltip.style.top = (event.pageY - 10) + "px";
            tooltip.style.opacity = 1;
        }

        function hideTooltip() {
            const tooltip = document.getElementById("tooltip");
            if (tooltip) {
                tooltip.style.opacity = 0;
            }
        }

        function renderEnhancedConflictGraph() {
            var container = document.getElementById("conflict-graph-container");
            if (!container) {
                console.warn("Conflict graph container not found");
                return;
            }
            
            if (!enchantments) {
                console.warn("Enchantments data not loaded yet");
                setTimeout(() => renderEnhancedConflictGraph(), 500);
                return;
            }
            
            if (typeof d3 === "undefined") {
                console.warn("D3.js not loaded, using simple HTML fallback");
                renderSimpleConflictGraph(container);
                return;
            }
            
            try {
                container.innerHTML = "";
                
                var width = container.clientWidth || 800;
                var height = 600;
                var svg = d3.select(container).append("svg")
                    .attr("width", width)
                    .attr("height", height)
                    .attr("viewBox", "0 0 " + width + " " + height);
                
                var centerX = width / 2;
                var centerY = height / 2;
                var orbitRadius = Math.min(width, height) * 0.22;
                
                var physicsNodes = [];
                var categoryNodes = [];
                var allEnchantmentNodes = [];
                
                // è®¡ç®—æ¯ä¸ªåˆ†ç±»çš„ä½ç½®ï¼ŒæŒ‰åœ†å‘¨åˆ†å¸ƒ
                var categories = Object.keys(enchantments);
                var angleStep = (Math.PI * 2) / categories.length;
                
                categories.forEach(function(catKey, catIndex) {
                    var catData = enchantments[catKey];
                    var angle = catIndex * angleStep - Math.PI / 2; // ä»é¡¶éƒ¨å¼€å§‹
                    var baseX = centerX + Math.cos(angle) * orbitRadius;
                    var baseY = centerY + Math.sin(angle) * orbitRadius;
                    
                    var enchantList = catData.enchantments || [];
                    var nodeCount = enchantList.length;
                    
                    // åˆ›å»ºåˆ†ç±»èŠ‚ç‚¹
                    var categoryNode = {
                        id: catKey,
                        name: catData.name,
                        color: catData.color,
                        icon: catData.icon || 'âš¡',
                        count: nodeCount,
                        x: baseX,
                        y: baseY,
                        vx: 0,
                        vy: 0,
                        radius: Math.max(30, Math.min(60, 20 + nodeCount * 0.8)),
                        isCategory: true,
                        parentId: null
                    };
                    
                    categoryNodes.push(categoryNode);
                    physicsNodes.push(categoryNode);
                    
                    // å¦‚æœåˆ†ç±»ä¸­æœ‰é™„é­”ï¼Œåˆ™å›´ç»•åˆ†ç±»èŠ‚ç‚¹åˆ†å¸ƒ
                    if (nodeCount > 0) {
                        var innerOrbitRadius = categoryNode.radius + 20;
                        var enchantAngleStep = (Math.PI * 2) / Math.max(1, nodeCount);
                        
                        enchantList.forEach(function(enchant, enchantIndex) {
                            var enchantAngle = enchantIndex * enchantAngleStep;
                            var enchantX = baseX + Math.cos(enchantAngle) * innerOrbitRadius;
                            var enchantY = baseY + Math.sin(enchantAngle) * innerOrbitRadius;
                            
                            var enchantNode = {
                                id: enchant.id,
                                name: enchant.name,
                                description: enchant.description,
                                parentColor: catData.color,
                                x: enchantX,
                                y: enchantY,
                                vx: 0,
                                vy: 0,
                                radius: 6,
                                isCategory: false,
                                parentId: catKey,
                                parentName: catData.name
                            };
                            
                            allEnchantmentNodes.push(enchantNode);
                            physicsNodes.push(enchantNode);
                        });
                    }
                });
                
                // åˆ›å»ºSVGå…ƒç´ 
                var defs = svg.append("defs");
                
                // ä¸ºæ¯ä¸ªåˆ†ç±»åˆ›å»ºæ¸å˜
                categoryNodes.forEach(function(node) {
                    var gradientId = "grad-" + node.id;
                    var gradient = defs.append("radialGradient")
                        .attr("id", gradientId)
                        .attr("cx", "50%")
                        .attr("cy", "50%")
                        .attr("r", "50%");
                    
                    gradient.append("stop")
                        .attr("offset", "0%")
                        .attr("stop-color", node.color)
                        .attr("stop-opacity", 0.9);
                    
                    gradient.append("stop")
                        .attr("offset", "100%")
                        .attr("stop-color", node.color)
                        .attr("stop-opacity", 0);
                    
                    node.gradientId = gradientId;
                });
                
                var linkGroup = svg.append("g").attr("class", "links");
                var nodeGroup = svg.append("g").attr("class", "nodes");
                var labelGroup = svg.append("g").attr("class", "labels");
                
                function getLinkType(cat1, cat2) {
                    var rules1 = conflictRules[cat1] || { conflicts: [], compatible: [], weak: [] };
                    if (rules1.conflicts.indexOf(cat2) >= 0) return "conflict";
                    if (rules1.compatible.indexOf(cat2) >= 0) return "compatible";
                    if (rules1.weak.indexOf(cat2) >= 0) return "weak";
                    return "weak";
                }
                
                function updateLinks() {
                    linkGroup.selectAll("*").remove();
                    
                    // åˆ†ç±»é—´è¿æ¥çº¿
                    for (var i = 0; i < categoryNodes.length; i++) {
                        for (var j = i + 1; j < categoryNodes.length; j++) {
                            var linkType = getLinkType(categoryNodes[i].id, categoryNodes[j].id);
                            if (linkType !== "none") {
                                linkGroup.append("line")
                                    .attr("class", "link " + linkType)
                                    .attr("x1", categoryNodes[i].x)
                                    .attr("y1", categoryNodes[i].y)
                                    .attr("x2", categoryNodes[j].x)
                                    .attr("y2", categoryNodes[j].y)
                                    .attr("stroke", linkType === "conflict" ? "#ff6b6b" : 
                                          linkType === "compatible" ? "#4ecdc4" : "#a0aec0")
                                    .attr("stroke-width", linkType === "conflict" ? 2 : 
                                          linkType === "compatible" ? 1 : 0.5)
                                    .attr("opacity", linkType === "conflict" ? 0.7 : 
                                          linkType === "compatible" ? 0.4 : 0.2);
                            }
                        }
                    }
                    
                    // é™„é­”ä¸åˆ†ç±»ä¹‹é—´çš„è¿æ¥çº¿
                    allEnchantmentNodes.forEach(function(enchantNode) {
                        var categoryNode = categoryNodes.find(function(n) { return n.id === enchantNode.parentId; });
                        if (categoryNode) {
                            linkGroup.append("line")
                                .attr("class", "link enchant-link")
                                .attr("x1", enchantNode.x)
                                .attr("y1", enchantNode.y)
                                .attr("x2", categoryNode.x)
                                .attr("y2", categoryNode.y)
                                .attr("stroke", categoryNode.color)
                                .attr("stroke-width", 0.5)
                                .attr("opacity", 0.15);
                        }
                    });
                }
                
                // åˆ›å»ºèŠ‚ç‚¹ç»„
                var nodeGroups = nodeGroup.selectAll(".node-group")
                    .data(physicsNodes)
                    .enter()
                    .append("g")
                    .attr("class", "node-group");
                
                // ç»˜åˆ¶èŠ‚ç‚¹
                nodeGroups.each(function(d) {
                    var g = d3.select(this);
                    
                    if (d.isCategory) {
                        // åˆ†ç±»èŠ‚ç‚¹ï¼šåœ†å½¢å¸¦æ¸å˜
                        g.append("circle")
                            .attr("class", "main")
                            .attr("r", d.radius)
                            .attr("fill", "url(#" + d.gradientId + ")")
                            .attr("stroke", "#fff")
                            .attr("stroke-width", 2)
                            .attr("opacity", 0.8);
                        
                        // æ·»åŠ å›¾æ ‡
                        g.append("text")
                            .attr("class", "label")
                            .attr("text-anchor", "middle")
                            .attr("dy", "0.3em")
                            .attr("fill", "#fff")
                            .attr("font-size", Math.max(12, d.radius / 2))
                            .text(d.icon);
                    } else {
                        // é™„é­”èŠ‚ç‚¹ï¼šå°åœ†å½¢
                        g.append("circle")
                            .attr("class", "main")
                            .attr("r", d.radius)
                            .attr("fill", d.parentColor)
                            .attr("stroke", "#fff")
                            .attr("stroke-width", 1)
                            .attr("opacity", 0.8);
                    }
                    
                    // æ·»åŠ å‘å…‰æ•ˆæœ
                    g.append("circle")
                        .attr("class", "glow")
                        .attr("r", d.isCategory ? d.radius * 1.8 : d.radius * 2)
                        .attr("fill", d.isCategory ? d.color : d.parentColor)
                        .attr("opacity", 0.2);
                });
                
                // åˆ›å»ºæ ‡ç­¾ç»„
                allEnchantmentNodes.forEach(function(node) {
                    var labelGroupItem = labelGroup.append("g")
                        .attr("class", "label-group label-" + node.id)
                        .attr("transform", "translate(" + node.x + "," + (node.y + node.radius + 15) + ")");
                    
                    labelGroupItem.append("text")
                        .attr("class", "enchant-label")
                        .attr("text-anchor", "middle")
                        .attr("fill", "#ccc")
                        .attr("font-size", "8px")
                        .attr("pointer-events", "none")
                        .text(node.name.length > 5 ? node.name.substring(0, 5) + ".." : node.name);
                });
                
                updateLinks();
                
                function getMousePos(event) {
                    var pt = svg.node().createSVGPoint();
                    var sourceEvent = event.sourceEvent || event;
                    pt.x = sourceEvent.clientX;
                    pt.y = sourceEvent.clientY;
                    return pt.matrixTransform(svg.node().getScreenCTM().inverse());
                }
                
                var draggedNode = null;
                
                function nodeEnter(event, d) {
                    d3.select(this).style("cursor", "grab");
                    if (d3.select(this).select("circle.main")) {
                        d3.select(this).select("circle.main")
                            .transition().duration(150).attr("r", d.radius * 1.4);
                    }
                    if (d3.select(this).select(".glow")) {
                        d3.select(this).select(".glow")
                            .transition().duration(150).attr("r", d.radius * 2).attr("opacity", 0.6);
                    }
                    showTooltip(event, d);
                }
                
                function nodeMove(event, d) {
                    showTooltip(event, d);
                }
                
                function nodeLeave(event, d) {
                    if (!d.isDragging) {
                        d3.select(this).select("circle.main")
                            .transition().duration(150).attr("r", d.radius);
                        d3.select(this).select(".glow")
                            .transition().duration(150).attr("r", d.radius * 1.8).attr("opacity", 0.2);
                    }
                    hideTooltip();
                }
                
                function nodeDragStart(event, d) {
                    d.isDragging = true;
                    draggedNode = d;
                    d3.select(this).style("cursor", "grabbing");
                }
                
                function nodeDrag(event, d) {
                    if (d === draggedNode) {
                        var pos = getMousePos(event);
                        d.x = Math.max(d.radius, Math.min(width - d.radius, pos.x));
                        d.y = Math.max(d.radius, Math.min(height - d.radius, pos.y));
                        d.vx = event.dx || 0;
                        d.vy = event.dy || 0;
                        updatePositions();
                        updateLinks();
                    }
                }
                
                function nodeDragEnd(event, d) {
                    if (d === draggedNode) {
                        d.isDragging = false;
                        d3.select(this).style("cursor", "grab");
                        draggedNode = null;
                    }
                }
                
                // æ·»åŠ æ‹–æ‹½è¡Œä¸º
                var drag = d3.drag()
                    .on("start", nodeDragStart)
                    .on("drag", nodeDrag)
                    .on("end", nodeDragEnd);
                
                nodeGroups.call(drag)
                    .on("mouseenter", nodeEnter)
                    .on("mousemove", nodeMove)
                    .on("mouseleave", nodeLeave);
                
                function updatePositions() {
                    nodeGroup.selectAll(".node-group").attr("transform", function(d) {
                        if (!d || d.x === undefined || d.y === undefined) return "";
                        return "translate(" + d.x + "," + d.y + ")";
                    });
                    
                    labelGroup.selectAll("[class^='label-']").each(function() {
                        var className = this.className.baseVal.replace("label-group ", "");
                        var id = className.replace("label-", "");
                        var nodeData = physicsNodes.find(function(n) { return n.id === id && !n.parentId; });
                        if (nodeData && nodeData.x !== undefined && nodeData.y !== undefined) {
                            d3.select(this).attr("transform", "translate(" + nodeData.x + "," + (nodeData.y + nodeData.radius + 15) + ")");
                        }
                    });
                }
                
                updatePositions();
                
            } catch (error) {
                console.error("Error rendering conflict graph:", error);
            }
        }
        
        // é¡µé¢åŠ è½½å®Œæˆåæ¸²æŸ“å›¾å½¢
        window.onload = function() {
            renderEnhancedConflictGraph();
        };
    </script>
</body>
</html>